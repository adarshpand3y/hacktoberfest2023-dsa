//recursive approach 
#include<bits/stdc++.h>
int findIndex(vector<int>&inorder,int element){
    for(int i=0;i<inorder.size();i++){
        if(inorder[i]==element)
        return i;
    }
    return -1;
}
TreeNode<int>*solve(vector<int>&inorder,vector<int>&preorder,int &index,int inorderStart,int inorderEnd,int size){
    if(index>=size || inorderStart>inorderEnd){
        return NULL;
    }
    int element = preorder[index++];
    TreeNode<int>*root = new TreeNode<int>(element);
    int position = findIndex(inorder,element);
    root->left = solve(inorder,preorder,index,inorderStart,position-1,size);
    root->right = solve(inorder,preorder,index,position+1,inorderEnd,size);
    return root;
}
TreeNode<int> *buildBinaryTree(vector<int> &inorder, vector<int> &preorder)
{
    int index =0;
    int n=inorder.size();
    TreeNode<int>*root = solve(inorder,preorder,index,0,n-1,n);
    return root;
}
//Another solution - (official)
TreeNode<int>*constructTree(int inStart,int inEnd,int &pIndex,unordered_map<int,int>&inorderIndex,vector<int>&preorder){
	if(inStart>inEnd){
		return NULL;
	}
	int rootNode = preorder[pIndex];
	pIndex = pIndex+1;
	TreeNode<int>*root = new TreeNode<int>(rootNode);
	if(inStart==inEnd){
		return root;
	}
	else{
		int inIndex = inorderIndex[root->data];
		TreeNode<int>*leftChild = constructTree(inStart,inIndex-1,pIndex,inorderIndex,preorder);
		TreeNode<int>*rightChild = constructTree(inIndex+1,inEnd,pIndex,inorderIndex,preorder);
		root->left = leftChild;
		root->right = rightChild;
		return root;
	}
}
TreeNode<int>*buildBinaryTree(vector<int>&inorder,vector<int>&preorder){
	unordered_map<int,int>inorderIndex;
	for(int i=0;i<inorder.size();i++){
		inorderIndex[inorder[i]] =i;
	}
	int pIndex =0;
	return constructTree(0,inorder.size()-1,pIndex,inorderIndex,preorder);
}