//brute approach
#include<bits/stdc++.h>
using namespace std;
//variant 1
string twoSum(vector<int>&arr,int target,int n){
	for(int i=0;i,n;i++){
		for(int j=1;j<n;j++){
			if(arr[i]+arr[j]==target)
			return "YES";
		}
	}
	return "NO";
}
//variant 2
vector<int>twoSum(vector<int>&arr,int target,int n){
	vector<int>ans;
	for(int i=0;i<n;i++){
		for(int j=i+1;j<n;j++){
			if(arr[i]+arr[j]==target){
				ans.push_back(i);
				ans.push_back(j);
				return ans;		
			}
		}
	}
	return {-1,-1};
}
//better approach - Hashing
//variant 1
string twoSum(vector<int>&arr,int target,int n){
	unordered_map<int,int>mp;
	for(int i=0;i<n;i++){
		int num = arr[i];
		int moreNeed = target-num;
		if(mp.find(moreNeed)!=mp.end()){
			return "YES";
		}
		mp[num] =i;
	}
	return "NO";
}
//variant 2
vector<int>twoSum(vector<int>&arr,int target,int n){
	unordered_map<int,int>mp;
	for(int i=0;i<n;i++){
		int num = arr[i];
		int moreNeed = target -num;
		if(mp.find(moreNeed)!=mp.end()){
			return {mp[moreNeed],i};
		}
		mp[num] =i;
	}
	return {-1,-1};
}
//Optimised solution - Two pointer approach
string twoSum(vector<int>&arr,int target,int n){
	sort(arr.begin(),arr.end());
	int left = 0,right = n-1;
	while(left<right){
		int sum = arr[left]+arr[right];
		if(sum==target){
			return "YES";
		}
		else if(sum<target)
		left++;
		else
		right--;
	}
	return "NO";
}