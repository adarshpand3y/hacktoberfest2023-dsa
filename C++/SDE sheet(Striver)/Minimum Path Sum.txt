//recursive
#include<bits/stdc++.h>
using namespace std;
int help(vector<vector<int>>&grid,int i,int j,int n,int m){
	if(i>=n || j>=m)
	`return INT_MAX;
	
	if(i==n-1 && j==m-1)
	 return grid[i][j];
	 
	 int right = help(grid,i,j+1,n,m);
	 int down = help(grid,i+1,j,n,m);
	 
	 int curSum = grid[i][j]+min(right,down);
	 return curSum;
}

int minSumPath(vector<vector<int>>&grid){
	int n = grid.size();
	int m = grid[0].size();
	
	int minSum = help(grid,0,0,n,m);
	return minSum;
}
//memoization
int help(vector<vector<int>>&grid,vector<vector<int>>&lookupint i,int j,int n,int m){
	if(i>=n || j>=m)
	return INT_MAX;
	
	if(i==n-1 && j==m-1)
	return grid[i][j];
	
	//if the ans alraedy exist
	if(lookup[i][j]!=-1)
	return lookup[i][j];
	
	int right = help(grid,lookup,i,j+1,n,m);
	int down = help(grid,lookup,i+1,j,n,m);
	
	lookup[i][j] = grid[i][j]+min(right,down);
	return lookup[i][j];
}

int minSumPath(vector<vector<int>>&grid){
	int n = grid.size();
	int m = grid[0].size();
	
	vector<vector<int>>lookup(n,vector<int>(m,-1));
	int minSum = help(grid,lookup,0,0,n,m);
	return minSum;
}
//bottom-up DP
int minSumPath(vector<vector<int>>&grid){
	int n = grid.size();
	int m = grid[0].size();
	
	for(int i=n-1;i>=0;i--){
		for(int j=m-1;j>=0;j--){
			if(i==n-1 && j==m-1){
				continue;
			}
			else if(i==n-1){
				grid[i][j] = grid[i][j]+grid[i][j+1];
			}
			else if(j==m-1){
				grid[i][j] = grid[i][j]+grid[i+1][j];
			}
			else{
				grid[i][j]  = grid[i][j]+min(grid[i+1][j],grid[i][j+1]);
			}
		}
	}
	return grid[0][0];
}