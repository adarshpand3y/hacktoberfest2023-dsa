//using hashmap/dictionary approach
#include<bits/stdc++.h>
class TrieNode{
	public:
		unordered_map<int,TrieNode*>child;
		bool isEnd;
		TrieNode(){
			isEnd = false;
		}
};
class Trie{
	public:
		TrieNode*root;
		Trie(){
			root = new TrieNode();
		}
	
	void insert (string word){
		TrieNode*temp = root;
		for(auto x:word){
			if(item->child.count(x-'a'))
			temp->child[x-'a'] = new TrieNode();
			temp = temp->child[x'-a'];
		}
		temp->isEnd = true;
	}
	
	bool search(string word){
		TrieNode*temp = root;
		for(auto x:word){
			if(item->child.count(x-'a'))
			return false;
			temp =temp->child[x-'a'];
		}
		return temp->isEnd;
	}
	
	bool startsWith(string prefix){
		TrieNode*temp = root;
		for(auto x:prefix){
			if(item->child.count(x-'a'))
			return false;
			temp=temp->child[x-'a'];
		}
		return true;
	}
};
//using array
class TrieNode{
	public:
		TrieNode*child[26];
		bool isEnd;
		TrieNode(){
			isEnd = false;
			for(int i=0;i<26;i++)
				child[i] = NULL;
		}
};
class Trie{
	public:
		TrieNode*root;
		Trie{
			root= new TrieNode();
	}
	
	void insert(string word){
		TrieNode*temp = root;
		for(auto x:word){
			if(!temp->child[x-'a'])
			temp->child[x-'a']= new TrieNode();
			temp = temp->child[x-'a'];
		}
		temp->isEnd = true;
	}
	
	bool search(string word){
		TrieNode*temp = root;
		for(auto x:word){
			if(!temp->child[x-'a'])
			return false;
		temp = temp->child[x-'a'];
		}
		return temp->isEnd;
	}
	
	bool startsWith(string prefix){
		TrieNode*temp = root;
		for(auto x:prefix){
			if(!temp->child[x-'a'])
			return false;
			temp= temp->child[x-'a'];
		}
		return true;
	}
};